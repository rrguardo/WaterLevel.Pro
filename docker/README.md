# Docker guide

This folder contains Docker-related configuration and runtime scripts.

Fast setup from zero (test/real domain):
- [`docs/SETUP_DOCKER_FAST.md`](../docs/SETUP_DOCKER_FAST.md)

## Quick start

1. Copy `.env.example` to `.env` at repository root.
2. Start all services:
	- `docker compose -f docker/docker-compose.yml up --build`
   - or: `./docker/up.sh`
	  - `up.sh` auto-creates `.env` from `.env.example` if missing
3. Open services:
	- Web (via Nginx): `https://localhost`
	- API (via Nginx host rule): `https://api.localhost`

Stop services:
- `./docker/down.sh`

View logs:
- `./docker/logs.sh`

Build app image directly:
- `docker build -f docker/Dockerfile -t rrguardo/waterlevel-pro:latest .`

Publish image to Docker Hub:
- `docker login`
- `docker push rrguardo/waterlevel-pro:latest`

## Runtime notes

- Redis runs inside the `app` container (port `6379` internal).
- Web and API run in the same `app` container (ports `8000` and `8001`).
- A dedicated `cron` container runs scheduled jobs from `ext_conf/crontab.ini`.
- SQLite persists in a Docker volume (`wlp_data`).
- On first run, `/app/data/database.db` is auto-created from `database.opensource.db`.
- Nginx writes access logs to a shared volume used by GoAccess.
- GoAccess generates live reports in `/app/reports` (mounted in `web` service).

Cron jobs in Docker include:

- alert workers (`email_alerts_cron.py`, `sms_alerts_cron.py`)
- daily/fulls reports from Nginx logs into `/app/reports`
- old report cleanup (retention)

## Networking and hostnames

Nginx hostnames/upstreams are configurable through `.env`:

- `APP_DOMAIN` (default: `https://localhost`)
- `API_DOMAIN` (default: `https://api.localhost`)
- `WLP_SERVER_NAME` (default: `localhost`)
- `WLP_API_SERVER_NAME` (default: `api.localhost`)
- `WLP_WEB_UPSTREAM` (default: `app:8000`)
- `WLP_API_UPSTREAM` (default: `app:8001`)
- `WLP_SSL_CERT_PATH` (default: `/etc/nginx/certs/localhost.crt`)
- `WLP_SSL_KEY_PATH` (default: `/etc/nginx/certs/localhost.key`)
- `WLP_APP_IMAGE` (default: `rrguardo/waterlevel-pro:latest`)

Minimal DNS layout (recommended for this SQLite-oriented setup):

- Web app on root domain: `example.com`
- API on subdomain of the same domain: `api.example.com`

This keeps routing, CORS, and deployment simple while the project is focused on
a single-node SQLite architecture (without external SQL server topology).

Nginx behavior in Docker:

- HTTP (`80`) always redirects to HTTPS (`443`).
- HTTPS routing is domain-based at Nginx level:
	- `${WLP_SERVER_NAME}` -> web upstream
	- `${WLP_API_SERVER_NAME}` -> api upstream
- Cloudflare real client IP is enabled through `CF-Connecting-IP` + trusted Cloudflare CIDRs.
- If configured cert/key files are missing, `nginx-entrypoint.sh` auto-generates a temporary self-signed cert in `/tmp/wlp-certs` (useful for CI and fresh local clones).

Example `.env` for production:

- `APP_DOMAIN=https://example.com`
- `API_DOMAIN=https://api.example.com`
- `WLP_SERVER_NAME=example.com`
- `WLP_API_SERVER_NAME=api.example.com`

After changing DNS values, recreate the stack:

- `docker compose -f docker/docker-compose.yml up -d --build`

To apply cron schedule changes from `ext_conf/crontab.ini`, recreate the `cron` service:

- `docker compose -f docker/docker-compose.yml up -d --build cron`

## Reports used by web app

The app reads report HTML files from `reports/`. In Docker this path is backed by
the shared `wlp_reports` volume, generated by GoAccess from Nginx logs.

Examples generated periodically:
- `WEB_LIVE.html`
- `API_LIVE.html`

## Entrypoint behavior

The container entrypoint initializes `/app/data/database.db` from
`database.opensource.db` when the database file does not exist.

This enables first-run startup with a ready demo dataset and persistent storage via volume.
